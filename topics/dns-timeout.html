<!doctype html> 
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <title>DNS Timeouts (Slow or Failing Resolution) | Network Packet Dictionary</title>
  <meta name="description" content="How to read packet captures when DNS seems to “hang”: separate timeouts from NXDOMAIN, see whether queries leave, where responses are lost, and decide if the issue is client, resolver, or network." />
  <meta name="robots" content="index,follow" />

  <link rel="stylesheet" href="/assets/css/styles.css" />

  <!-- Topics P0 v1.0: SAFE SCOPE (ONLY inside <article class="content">) -->
  <style>
    /* Wireshark filter block (scoped) */
    .content pre.ws-filter{
      margin:0.4em 0 1em;
      padding:0.6em 0.8em;
      border-radius:8px;
      background:rgba(0,0,0,0.06);
      border:1px solid rgba(0,0,0,0.10);
      overflow-x:auto;
    }
    .content pre.ws-filter code{
      background:none;
      padding:0;
      border:none;
      font-size:0.95em;
      user-select:text;
      font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;
    }

    /* Sub-section emphasis (scoped) */
    .content h3{
      font-size:1.2em;
      font-weight:900;
      margin-top:1.6em;
      margin-bottom:0.45em;
    }

    /* Issue-style blocks for “success/failure” (scoped) */
    .content dl.issue{
      margin:0.6em 0 1.4em;
      padding:0.9em 1em;
      border-radius:10px;
      background:rgba(0,0,0,0.04);
      border:1px solid rgba(0,0,0,0.08);
    }
    .content dl.issue dt{
      font-weight:900;
      margin-top:0.65em;
    }
    .content dl.issue dt:first-child{ margin-top:0; }
    .content dl.issue dd{
      margin:0.2em 0 0.45em;
      opacity:0.95;
      line-height:1.65;
    }
    .content dl.issue dd + dt{ margin-top:0.75em; }

    /* Ordered list emphasis (scoped) */
    .content ol{ margin:0.6em 0 1.2em; padding-left:1.4em; }
    .content ol li{ margin:0.4em 0; line-height:1.6; }
    .content ol li::marker{ font-weight:900; }
  </style>

  <!-- v1.0 rule: AdSense script must NOT be embedded in topics pages -->
   <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-5493851170081090"
     crossorigin="anonymous"></script>
</head>

<body data-ads="on">
  <header class="header">
    <div class="header-inner">
      <a class="brand" href="/">
        <div class="logo"></div>
        <div>
          <div class="brand-title">Network Packet Dictionary</div>
        </div>
      </a>
      <nav class="nav" aria-label="Site">
        <a href="/dictionary.html">Dictionary</a>
        <a href="/fields.html">Fields</a>
        <a href="/topics.html">Topics</a>
        <a href="/tools.html">Tools</a>
        <a href="/about.html">About</a>
      </nav>
    </div>
  </header>

  <main class="wrap">
    <section class="card">

      <div class="ad">Ad slot (topics-top)</div>

      <article class="content">
        <h1>DNS Timeouts (Slow or Failing Resolution)</h1>

        <h2>The scenario (Why you care)</h2>
        <p>
          “The page just spins forever.” When DNS is slow or silently failing, users rarely say “DNS is broken.”
          They say that websites hang on the first load, some applications never reach their servers, or VPN logins stall
          before showing any login screen. In many environments, a DNS timeout is the <em>first</em> failure the user feels.
        </p>
        <p>
          From the host’s perspective, a DNS timeout means it sent a query and waited for an answer that never arrived.
          Many resolvers retry the same query, or try a secondary resolver, before finally giving up. This creates long gaps
          in application behavior: 3–10 seconds of waiting before anything else can happen. In packet captures, that delay
          is visible and measurable—if you know where to look and how to distinguish a true timeout from a normal “no such name”
          (NXDOMAIN) or an application that is simply slow.
        </p>
        <p>
          This topic focuses on how to read captures when “DNS looks slow” or “name resolution sometimes never completes” and how
          to decide whether the issue is the client, the resolver, or the network between them.
        </p>

        <h2>What “good” looks like (Success pattern)</h2>
        <dl class="issue">
          <dt>What you see</dt>
          <dd>
            For each application access, you see one or more DNS queries followed very quickly by matching responses
            (usually within a few milliseconds to tens of milliseconds). Transaction IDs match, response codes are
            “NoError”, and the client moves on immediately to TCP/TLS connections. Repeated visits often show fewer DNS
            queries because of caching.
          </dd>

          <dt>Why it happens</dt>
          <dd>
            The client can reach at least one healthy recursive resolver, that resolver can reach the authoritative servers,
            and the entire path for queries and responses is free of blocking or asymmetric routing. Caching at multiple layers
            (OS, browser, resolver) reduces the number of queries needed after the first lookup.
          </dd>

          <dt>Key clue</dt>
          <dd>
            In the capture, the time delta between DNS query and response is small and consistent, and you see the client
            immediately open TCP connections to the returned IP addresses without long idle gaps.
          </dd>
        </dl>

        <h2>What goes wrong (Failure pattern)</h2>
        <dl class="issue">
          <dt>What you see</dt>
          <dd>
            DNS queries go out, but responses do not come back in a timely way. You may see the same query retransmitted
            several times to the same resolver or to multiple resolvers configured on the client. Eventually the client gives up,
            reports a timeout, or falls back to cached data. In other cases, some names resolve instantly while others for the same
            application hang for seconds or never complete.
          </dd>

          <dt>Likely causes</dt>
          <dd>
            Typical causes include: the primary resolver being unreachable or overloaded, a firewall or ACL blocking
            UDP/53 or large responses, broken anycast routing to a public resolver, middleboxes mangling EDNS0 or DNSSEC-related
            responses, or misconfigured clients pointing at a non-existent DNS server. Sometimes only specific domains are affected
            because an upstream forwarder or authoritative server is slow or unreachable.
          </dd>

          <dt>Key clue</dt>
          <dd>
            The defining sign of a DNS timeout problem is a long gap between query and any usable response—often multiple seconds—
            combined with repeated queries for the same name and no DNS error code such as NXDOMAIN or SERVFAIL that would allow
            the application to fail fast.
          </dd>
        </dl>

        <h2>Signals &amp; decision table</h2>
        <p>
          This decision table helps you separate “DNS timeout” from “normal negative answer” and pinpoint whether the problem
          is at the client, resolver, or network layer.
        </p>
        <table>
          <thead>
            <tr>
              <th>Signal you see</th>
              <th>What it suggests</th>
              <th>What to check next</th>
              <th>Related field/protocol</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>DNS query sent, no response, repeated several times</td>
              <td>Resolver unreachable or replies blocked</td>
              <td>Verify if any response from that resolver IP appears; check UDP/53 reachability and firewall rules</td>
              <td>DNS header (Transaction ID), UDP/53</td>
            </tr>
            <tr>
              <td>First DNS lookup slow, later lookups fast for same name</td>
              <td>Upstream resolver or authoritative path slow, caching hides problem after first hit</td>
              <td>Compare RTT for cache miss vs hit; inspect which server the slow query targets</td>
              <td>DNS flags (RD/RA), response TTL</td>
            </tr>
            <tr>
              <td>NXDOMAIN or SERVFAIL returned quickly (no long gaps)</td>
              <td>Not a timeout; domain truly does not resolve or is misconfigured</td>
              <td>Confirm RCODE and question name; focus on DNS configuration, not connectivity</td>
              <td>DNS RCODE, question section</td>
            </tr>
            <tr>
              <td>Client queries multiple resolvers in sequence before success</td>
              <td>Primary resolver slow or down; secondary works</td>
              <td>Check health and latency of each resolver; ensure client resolver order is intentional</td>
              <td>DNS server IPs, query timing</td>
            </tr>
            <tr>
              <td>Only large responses (many records, DNSSEC, EDNS0) seem affected</td>
              <td>Truncation or UDP size issues causing retries or drops</td>
              <td>Look for TC flag and TCP fallback; examine EDNS0 advertised size and firewalls on UDP fragments</td>
              <td>DNS flags (TC), EDNS0, TCP/53</td>
            </tr>
            <tr>
              <td>DNS looks fine, but application still waits before connect</td>
              <td>Problem likely above DNS (TLS handshake or server latency)</td>
              <td>Correlate DNS finish time with first TCP SYN to target IP</td>
              <td>DNS vs TCP timeline</td>
            </tr>
          </tbody>
        </table>

        <h2>How it looks in Wireshark</h2>
        <p><strong>Display filter example:</strong></p>
        <pre class="ws-filter"><code>dns &amp;&amp; dns.flags.response == 0</code></pre>
        <ul>
          <li>
            Focus on queries first: with the filter above you see outbound DNS requests and can measure how long it takes
            before the matching response (same Transaction ID, source/destination swapped) appears.
          </li>
          <li>
            Timeouts show up as queries with no matching response at all, followed by identical retransmissions or queries
            to a different DNS server IP. The gaps between these attempts correspond directly to the user’s perceived delay.
          </li>
          <li>
            By adding columns for “DNS response time” or by following a single Transaction ID, you can quickly distinguish
            consistent low-latency lookups (healthy) from occasional very slow or missing responses (suspect path or resolver).
          </li>
        </ul>
        <p>
          <strong>Quick read tip:</strong> When an application “hangs on lookup,” align the DNS timeline with the moment the
          user clicked. If you see several seconds of repeated DNS queries with no answer before any TCP connection attempts,
          you are dealing with a DNS timeout, not a slow web server.
        </p>

        <h2>Fast triage checklist</h2>
        <ol>
          <li>
            Reproduce the issue while capturing on the client side. Note the exact time when the user triggered the failing action
            (for example opening a URL or starting a VPN).
          </li>
          <li>
            Filter on DNS and identify the first query for the name in question. Measure how long it takes until a response or
            until the client gives up and tries another resolver or another name.
          </li>
          <li>
            Classify the outcome: fast positive answer, fast NXDOMAIN/SERVFAIL, or repeated queries with no answer. Only the last
            pattern is a true timeout.
          </li>
          <li>
            If timeouts are confirmed, capture closer to the resolver or along the path to see whether responses are generated
            but lost in transit, or if the resolver itself is not replying.
          </li>
          <li>
            Decide where the permanent fix belongs: client settings (wrong DNS IPs, bad resolver order), resolver capacity or
            configuration, or network policy (firewalls, rate limits, UDP/fragment handling) between client and resolver.
          </li>
        </ol>

        <h2>Common pitfalls</h2>
        <h3>Confusing NXDOMAIN with a timeout</h3>
        <p>
          A quick NXDOMAIN is a clear, useful answer—even if the user sees an error page. It means the DNS machinery worked,
          but the name itself is invalid or misconfigured. Treating NXDOMAIN as “DNS timeout” leads you to chase network ghosts
          instead of fixing host files, zone records, or application configuration that references the wrong name.
        </p>

        <h3>Only capturing above the resolver</h3>
        <p>
          If you capture on the far side of a recursive resolver (for example at an internet edge), you may only see the resolver’s
          traffic to authoritative servers, not the original client queries. When troubleshooting timeouts, you need a view that
          includes the client-to-resolver leg; otherwise, you cannot tell whether the resolver never got the query, never answered,
          or answered but the client never received the response.
        </p>

        <h3>Ignoring multiple resolvers and split-horizon setups</h3>
        <p>
          Many clients use more than one DNS server, and many enterprises use split-horizon DNS with different answers internally
          and externally. If you only look at one resolver’s traffic, you can miss that the client is quietly failing over to
          another server or getting conflicting answers from different views. Always check which resolver IP each query is sent to
          and whether timeouts occur only when a specific resolver is involved.
        </p>

        <h2>Related pages (internal links)</h2>
        <ul>
          <li><a href="/topics.html">Back to Topics Index</a></li>
          <li><a href="/dictionary/dns.html">Dictionary: DNS overview</a></li>
          <li><a href="/fields/dns-rcode.html">Field: DNS RCODE (Response Code)</a></li>
          <li><a href="/dictionary.html">Dictionary Index</a></li>
        </ul>

        <!--
        Topics P0 v1.0 checklist
        - Safe-scope CSS: YES (all selectors under .content)
        - data-ads: on
        - 700–1200 words: verify before publishing
        - Table >= 1: YES (decision table)
        - Lists: YES (ul + ol)
        - Internal links >= 4: topics + dictionary + field + dictionary index
        - Soon is not linked: yes (text only)
        - Wireshark filter uses <pre class="ws-filter"><code>...</code></pre>: yes
        - AdSense script embedded here: NO
        -->
      </article>

      <div class="ad">Ad slot (topics-bottom)</div>

    </section>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      <div>
        <a href="/legal/privacy.html">Privacy</a>
        <a href="/legal/terms.html">Terms</a>
        <a href="/about.html">About</a>
        <a href="/contact.html">Contact</a>
      </div>
      <div class="copyright">© Network Packet Dictionary</div>
    </div>
  </footer>

  <script src="/assets/js/site.js"></script>
</body>
</html>
